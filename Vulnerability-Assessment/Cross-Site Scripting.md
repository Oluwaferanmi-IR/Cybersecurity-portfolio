#  Cross-Site Scripting (XSS) ‚Äì DVWA Lab

##  Overview
This repository shows hands-on practice with **Cross-Site Scripting (XSS)** vulnerabilities using **Damn Vulnerable Web Application (DVWA)** in a controlled test environment.

The purpose of this project is to:
- Understand XSS vulnerabilities
- Demonstrate how injected scripts execute in browser memory
- Analyze real-world security impact
- Practice ethical exploitation and professional documentation

---

##  What is Cross-Site Scripting (XSS)?
Cross-Site Scripting (XSS) is a web vulnerability that occurs when an application accepts user input and displays it back to users without proper validation or encoding, allowing attackers to inject JavaScript that executes in a victim‚Äôs browser.

XSS is a **client-side attack** that abuses the **trust between a user and a website**, not the server itself.

---

##  Lab Environment

| Component | Description |
|---------|------------|
| Target Application | Damn Vulnerable Web Application (DVWA) |
| Attacker Machine | Kali Linux |
| Web Server | Apache |
| Browser | Firefox |
| DVWA Security Level | Low (learning mode) |

---

## üõ†Ô∏è Tools Used

- Kali Linux
- DVWA
- Firefox Developer Tools

---

##  XSS Types Covered

- Reflected XSS
- Stored XSS


---

##  Methodology: Reflected Cross-Site Scripting (XSS)

This methodology describes the step-by-step approach used to identify and validate **Reflected XSS** vulnerabilities in a controlled lab environment such as DVWA. Reflected Cross‚ÄëSite Scripting (XSS) is a web vulnerability where a user input is sent to a website and immediately reflected back in the response without proper filtering, causing the browser to execute it as code. Nothing gets saved to the server.

### 1Ô∏è. Identify Input Points
The first step is to locate areas of the application where user input is accepted and immediately reflected back in the response.For our test environment, the input point is quite obvious, we would use the XSS reflected shown on the webpage 

<img width="1081" height="716" alt="Screenshot 2026-02-02 140616" src="https://github.com/user-attachments/assets/b2cd7608-dcd6-4e77-9ec3-f30bb52ef894" />

Common input points include:
- Search fields
- URL parameters
- Login error messages
- Form fields that return validation feedback


### 2Ô∏è. Submit Test Input
After identifying the input point, a random test input is submitted to determine whether user input is reflected back to the browser.

<img width="1074" height="654" alt="Screenshot 2026-02-02 141530" src="https://github.com/user-attachments/assets/02615264-ea91-4f4c-90ac-191f696a6c23" />

The goal at this stage is to confirm:
- Input is not properly sanitized
- Input appears in the server‚Äôs HTTP response

### 3Ô∏è. Observe Application Response
After submitting the input, the page response is analyzed to see:
- Where the input appears
- Whether it is rendered as text or executed by the browser
- Whether any filtering or encoding is applied

Browser Developer Tools and Burp Suite can be used to inspect responses.

### 4Ô∏è. Test JavaScript Execution
run the code <scipt>alert('1')</script> to check for possible xss vulnerability. If the pop-up 1 shows, it means the vulnerabilty is there.

<img width="1086" height="656" alt="Screenshot 2026-02-02 142310" src="https://github.com/user-attachments/assets/61c4855f-e194-4832-8f80-9c825edbb6f2" />

This step verifies that:
- That is a cross-site scripting vulnerability.
- The vulnerability is exploitable
- The execution occurs immediately after submission


### **5.**  Mitigations Strategies
Appropriate mitigation strategies for xss vulnerabilities includes
- Input validation
- Output encoding
- Context-aware escaping
- Implementation of Content Security Policy (CSP)


##  Key Notes on Reflected XSS
- Reflected XSS is non-persistent
- The payload is not stored on the server
- The attack typically requires user interaction (e.g., clicking a link)
- Execution happens immediately in the victim‚Äôs browser


##  Conclusion
Reflected XSS demonstrates how improper handling of user input can lead to immediate client-side code execution. Even though it is often considered less severe than stored XSS, it can still result in serious security breaches when combined with social engineering.

---

##  Methodology: Stored Cross-Site Scripting (XSS)

This methodology shows the systematic approach used to identify and validate **Stored Cross-Site Scripting (XSS)** vulnerabilities in intentionally vulnerable web applications such as DVWA. Stored vulnerability is a type of xss vulnerability where malicious input is saved on the server and later executed automatically in every user‚Äôs browser that views it.



### 1Ô∏è. Identify Persistent Input Fields
The first step is to locate application features that accept user input and store it on the server for later display. For the purpose of this lab, I used the DVWA XSS stored page available on the DVWA webpage.

<img width="1078" height="711" alt="Screenshot 2026-02-02 143643" src="https://github.com/user-attachments/assets/dfa0e09a-301e-4f64-9ef1-0fbb6f84b777" />

Common example of this input field include:
- Comment sections
- Message boards
- User profiles
- Product reviews
- Feedback forms

### 2Ô∏è. Submit Controlled Test Input
A random test input is submitted through the identified input field to observe how the application processes and stores user data.
what ever you input should be returned and stored.

<img width="1078" height="711" alt="Screenshot 2026-02-02 143643" src="https://github.com/user-attachments/assets/62bd419b-ec5e-4a9d-bcb1-1c44526405af" />

The purpose of this step is to determine whether:
- Input validation is enforced
- Output encoding is applied before storage or display

### 3Ô∏è. Reload or Revisit the Affected Page
After submitting the input, the affected page is reloaded or revisited.

This step confirms:
- Whether the input persists after submission
- Whether stored content is rendered back.

### 4Ô∏è. Verify Javascript Execution
If the application fails to sanitize stored input, the browser may interpret the content as executable code. run <script>salert('stored xss)</script>. if there is no output encoding, the code will run and it would be saved to run persistently on the brower of anyone that visits the page. But if output encoding has been put in place, the code will retun to you as plain text.

<img width="1082" height="712" alt="Screenshot 2026-02-02 144842" src="https://github.com/user-attachments/assets/f724b077-9726-4472-b38d-2985ff9c64b7" />

A script test is used to confirm:
- Successful execution in the browser
- Persistence of the injected content
- Automatic triggering without further user interaction

### 6Ô∏è Security Impact
The potential consequences of the stored XSS vulnerability are evaluated, including:
- Session hijacking
- User impersonation
- Phishing attacks
- Unauthorized actions
- Malware delivery through trusted pages


### 8Ô∏è Mitigation Strategies
Appropriate remediation steps are identified, including:
- Server-side input validation
- Output encoding at render time
- Use of Content Security Policy (CSP)
- Secure handling of user-generated content
- Proper use of security headers

##  Key Characteristics of Stored XSS

- Payload is **persistently stored**
- Executes automatically when the page loads
- Affects multiple users
- Generally higher impact than reflected XSS
- Often exploited without user interaction


##  Conclusion
Stored XSS is one of the most severe client-side vulnerabilities because it allows persistent execution of malicious scripts within trusted web pages. Proper input handling and output encoding are critical to preventing this class of attack.

---

##  Security Impact

If exploited maliciously, XSS vulnerabilities can be used to:

- Steal session cookies
- Perform actions as authenticated users
- Inject phishing forms into trusted pages

---

##  Defense Techniques

- Proper input validation and sanitization
- Output encoding (HTML, JavaScript, URL contexts)
- Implementation of Content Security Policy (CSP)
- Setting cookies with `HttpOnly` and `Secure` flags
- Avoiding unsafe DOM manipulation with untrusted input

---


